#!/usr/bin/env python3
"""
Create Shortcut stories from PM-REVIEWED theme groups.

IMPORTANT: This script requires PM review results. Run the full pipeline:
  1. python scripts/extract_themes_async.py --max 1000
  2. python scripts/run_pm_review_all.py        # REQUIRED - validates groupings
  3. python scripts/create_theme_stories.py     # This script - only after PM review

Direct theme-to-story creation bypasses the PM review quality gate.
Use --skip-pm-review only for testing/debugging.

Usage:
    python scripts/create_theme_stories.py                    # Normal - requires PM review
    python scripts/create_theme_stories.py --dry-run          # Preview
    python scripts/create_theme_stories.py --skip-pm-review   # TESTING ONLY - bypass PM review
"""
import json
import os
import sys
from collections import defaultdict
from pathlib import Path

import requests

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))
from story_formatter import format_excerpt

PM_REVIEW_FILE = Path(__file__).parent.parent / "data" / "pm_review_results.json"


def check_pm_review_exists(skip_check: bool = False) -> dict | None:
    """Check that PM review has been run. Returns review results or None."""
    if skip_check:
        print("WARNING: Skipping PM review check (--skip-pm-review flag)")
        print("         Stories will be created without PM validation!")
        print()
        return None

    if not PM_REVIEW_FILE.exists():
        print("ERROR: PM review results not found!")
        print()
        print("You must run PM review before creating stories:")
        print("  1. python scripts/extract_themes_async.py --max 1000")
        print("  2. python scripts/run_pm_review_all.py        # <-- Missing!")
        print("  3. python scripts/create_theme_stories.py")
        print()
        print("To bypass (TESTING ONLY): --skip-pm-review")
        sys.exit(1)

    with open(PM_REVIEW_FILE) as f:
        reviews = json.load(f)

    print(f"Found PM review results: {len(reviews)} groups reviewed")
    return {r["signature"]: r for r in reviews}


def load_env():
    """Load environment variables from .env file."""
    env_file = Path(__file__).parent.parent / ".env"
    if env_file.exists():
        for line in env_file.read_text().splitlines():
            if "=" in line and not line.startswith("#"):
                k, v = line.split("=", 1)
                os.environ.setdefault(k.strip(), v.strip())


def build_theme_story_description(signature: str, data: dict, total: int) -> str:
    """Build Shortcut story description for a specific theme."""
    pct = data["count"] / total * 100 if total > 0 else 0

    # Get product area and component from first sample
    first = data["samples"][0] if data["samples"] else {}
    product_area = first.get("product_area", "unknown")
    component = first.get("component", "unknown")

    # Aggregate symptoms and user intents
    all_symptoms = []
    user_intents = set()
    root_causes = set()

    for sample in data["samples"]:
        for s in sample.get("symptoms", []):
            if s and s not in all_symptoms:
                all_symptoms.append(s)
        if sample.get("user_intent"):
            user_intents.add(sample["user_intent"])
        if sample.get("root_cause_hypothesis"):
            root_causes.add(sample["root_cause_hypothesis"])

    symptoms_md = "\n".join(f"- {s}" for s in all_symptoms[:10]) or "- No symptoms captured"
    intents_md = "\n".join(f"- {i}" for i in list(user_intents)[:5]) or "- Not captured"
    causes_md = "\n".join(f"- {c}" for c in list(root_causes)[:3]) or "- Needs investigation"

    description = f"""## Theme: {signature.replace('_', ' ').title()}

**Issue Signature**: `{signature}`
**Product Area**: {product_area}
**Component**: {component}
**Occurrences**: {data['count']} ({pct:.1f}% of analyzed conversations)

---

## User Intents

{intents_md}

## Reported Symptoms

{symptoms_md}

## Root Cause Hypotheses

{causes_md}

---

## Sample Customer Reports

"""
    for i, sample in enumerate(data["samples"][:5], 1):
        formatted = format_excerpt(
            conversation_id=sample.get("id", "unknown"),
            email=sample.get("email"),
            excerpt=sample.get("excerpt", ""),
            org_id=sample.get("org_id"),
            user_id=sample.get("user_id"),
            intercom_url=sample.get("intercom_url"),
            jarvis_org_url=sample.get("jarvis_org_url"),
            jarvis_user_url=sample.get("jarvis_user_url"),
        )
        affected_flow = sample.get("affected_flow", "Not specified")
        description += f"### Report {i}\n{formatted}\n\n**Affected Flow**: {affected_flow}\n\n"

    description += """---

## Review Checklist
- [ ] Theme grouping is correct (similar root issues)
- [ ] Symptoms accurately describe the problem
- [ ] Root cause hypothesis is reasonable
- [ ] Priority should be: ___

---
*Generated by FeedForward Theme Extraction Pipeline*
"""
    return description


def get_backlog_state_id(headers: dict) -> int:
    """Get the Backlog workflow state ID from Shortcut."""
    resp = requests.get(
        "https://api.app.shortcut.com/api/v3/workflows",
        headers=headers
    )
    resp.raise_for_status()
    workflows = resp.json()

    for wf in workflows:
        for state in wf.get("states", []):
            if state["name"] == "Backlog":
                return state["id"]

    raise ValueError("Could not find Backlog state")


def determine_story_type(signature: str, product_area: str) -> str:
    """Determine Shortcut story type based on theme."""
    # Bug indicators
    bug_keywords = ["failure", "error", "broken", "not_working", "crash", "timeout"]
    if any(kw in signature for kw in bug_keywords):
        return "bug"

    # Feature request indicators
    feature_keywords = ["request", "enhancement", "want", "need", "missing"]
    if any(kw in signature for kw in feature_keywords):
        return "feature"

    # Billing/account are usually chores
    if product_area in ["billing", "account"]:
        return "chore"

    # Default to bug for technical issues
    return "bug"


def create_stories(input_file: Path, dry_run: bool = False, min_count: int = 1, skip_pm_review: bool = False):
    """Create Shortcut stories from PM-reviewed theme groups."""
    load_env()

    # REQUIRED: Check PM review has been run
    pm_reviews = check_pm_review_exists(skip_check=skip_pm_review)

    token = os.getenv("SHORTCUT_API_TOKEN")
    if not token:
        print("ERROR: SHORTCUT_API_TOKEN not set")
        sys.exit(1)

    token = token.strip()
    headers = {
        "Content-Type": "application/json",
        "Shortcut-Token": token,
    }

    if not input_file.exists():
        print(f"ERROR: Input file not found: {input_file}")
        print("Run extract_themes_to_file.py first.")
        sys.exit(1)

    # Aggregate by issue_signature
    aggregated = defaultdict(lambda: {"count": 0, "samples": []})

    with open(input_file) as f:
        for line in f:
            r = json.loads(line)
            sig = r.get("issue_signature", "unknown")
            aggregated[sig]["count"] += 1
            if len(aggregated[sig]["samples"]) < 5:
                aggregated[sig]["samples"].append(r)

    total = sum(d["count"] for d in aggregated.values())

    # Filter by min_count and sort
    filtered = [(sig, data) for sig, data in aggregated.items()
                if data["count"] >= min_count and sig not in ["spam", "error", "unknown"]]
    sorted_themes = sorted(filtered, key=lambda x: x[1]["count"], reverse=True)

    print(f"\n{'='*60}")
    print("Creating Shortcut Stories from Theme Extractions")
    print(f"{'='*60}")
    print(f"Input: {input_file}")
    print(f"Total conversations: {total}")
    print(f"Unique themes: {len(aggregated)}")
    print(f"Themes with >= {min_count} occurrences: {len(sorted_themes)}")
    print(f"Dry run: {dry_run}")
    print()

    if not dry_run:
        backlog_state_id = get_backlog_state_id(headers)

    stories_created = []

    for signature, data in sorted_themes:
        first = data["samples"][0] if data["samples"] else {}
        product_area = first.get("product_area", "unknown")
        story_type = determine_story_type(signature, product_area)

        # Create readable title
        title_sig = signature.replace("_", " ").title()
        story_name = f"[{data['count']}] {title_sig}"

        if dry_run:
            print(f"Would create: {story_name}")
            print(f"  Type: {story_type}, Area: {product_area}")
            print(f"  Samples: {len(data['samples'])}")
            print()
        else:
            description = build_theme_story_description(signature, data, total)

            story_data = {
                "name": story_name,
                "description": description,
                "story_type": story_type,
                "workflow_state_id": backlog_state_id,
            }

            try:
                resp = requests.post(
                    "https://api.app.shortcut.com/api/v3/stories",
                    json=story_data,
                    headers=headers,
                )
                resp.raise_for_status()
                story = resp.json()
                stories_created.append({
                    "name": story_name,
                    "url": story["app_url"]
                })
                print(f"Created: {story_name}")
                print(f"  URL: {story['app_url']}")
            except Exception as e:
                print(f"ERROR creating story for {signature}: {e}")

    print(f"\n{'='*60}")
    if dry_run:
        print(f"Dry run complete. Would create {len(sorted_themes)} stories.")
    else:
        print(f"Created {len(stories_created)} Shortcut stories for review")
    print("="*60)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Create Shortcut stories from theme extractions")
    parser.add_argument(
        "--input",
        type=Path,
        default=Path(__file__).parent.parent / "data" / "theme_extraction_results.jsonl",
        help="Input JSONL file from extract_themes_to_file.py"
    )
    parser.add_argument("--dry-run", action="store_true", help="Preview without creating")
    parser.add_argument("--min-count", type=int, default=1, help="Minimum occurrences to create story")
    parser.add_argument("--skip-pm-review", action="store_true",
                        help="TESTING ONLY: Bypass PM review requirement")

    args = parser.parse_args()
    create_stories(args.input, args.dry_run, args.min_count, args.skip_pm_review)
