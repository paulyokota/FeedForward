"""
Shortcut story formatting - single source of truth.

All story creation should use these functions to ensure consistent formatting.

Format spec:
- Excerpts link to Intercom conversation, Jarvis org page, Jarvis user page
- Description includes category, count, percentage, samples, review checklist
- Footer identifies FeedForward as the generator
"""

import os
from typing import Optional

INTERCOM_APP_ID = os.getenv("INTERCOM_APP_ID", "2t3d8az2")


def format_excerpt(
    conversation_id: str,
    email: Optional[str] = None,
    excerpt: str = "",
    org_id: Optional[str] = None,
    user_id: Optional[str] = None,
    intercom_url: Optional[str] = None,
    jarvis_org_url: Optional[str] = None,
    jarvis_user_url: Optional[str] = None,
) -> str:
    """
    Format a conversation excerpt with linked metadata.

    Format: [email](intercom_url) | [Org](jarvis_org_url) | [User](jarvis_user_url)
    > excerpt text...

    Args:
        conversation_id: Intercom conversation ID
        email: Customer email address
        excerpt: Conversation excerpt text
        org_id: Tailwind org ID (for Jarvis URL)
        user_id: Tailwind user ID (for Jarvis URL)
        intercom_url: Pre-built Intercom URL (optional, will build if not provided)
        jarvis_org_url: Pre-built Jarvis org URL (optional)
        jarvis_user_url: Pre-built Jarvis user URL (optional)

    Returns:
        Formatted markdown string
    """
    parts = []

    # Build URLs if not provided
    if not intercom_url:
        intercom_url = f"https://app.intercom.com/a/apps/{INTERCOM_APP_ID}/inbox/inbox/conversation/{conversation_id}"

    if not jarvis_org_url and org_id:
        jarvis_org_url = f"https://jarvis.tailwind.ai/organizations/{org_id}"

    if not jarvis_user_url and org_id and user_id:
        jarvis_user_url = f"https://jarvis.tailwind.ai/organizations/{org_id}/users/{user_id}"

    # Email linked to Intercom conversation
    display_email = email or f"Conversation {conversation_id}"
    parts.append(f"[{display_email}]({intercom_url})")

    # Org linked to Jarvis
    if jarvis_org_url:
        parts.append(f"[Org]({jarvis_org_url})")

    # User linked to Jarvis
    if jarvis_user_url:
        parts.append(f"[User]({jarvis_user_url})")

    user_info = " | ".join(parts)
    excerpt_text = excerpt[:300] if excerpt else ""

    return f"{user_info}\n> {excerpt_text}"


def build_story_description(
    category: str,
    count: int,
    total: int,
    samples: list[dict],
    pipeline_name: str = "FeedForward Classification Pipeline",
    time_period: str = "Last 30 Days",
) -> str:
    """
    Build Shortcut story description with formatted excerpts.

    Args:
        category: Classification category name
        count: Number of conversations in this category
        total: Total conversations analyzed
        samples: List of sample conversation dicts with keys:
            - id: conversation ID
            - email: customer email (optional)
            - excerpt: conversation text
            - org_id: Tailwind org ID (optional)
            - user_id: Tailwind user ID (optional)
            - intercom_url: pre-built URL (optional)
            - jarvis_org_url: pre-built URL (optional)
            - jarvis_user_url: pre-built URL (optional)
        pipeline_name: Name of the generating pipeline
        time_period: Description of time period analyzed

    Returns:
        Formatted markdown description
    """
    pct = count / total * 100 if total > 0 else 0

    description = f"""## Classification Results ({time_period})

**Category**: {category}
**Count**: {count} ({pct:.1f}% of total)
**Total Conversations Analyzed**: {total}

---

## Sample Conversations

"""
    for i, sample in enumerate(samples[:5], 1):
        formatted = format_excerpt(
            conversation_id=sample.get("id", "unknown"),
            email=sample.get("email"),
            excerpt=sample.get("excerpt", ""),
            org_id=sample.get("org_id"),
            user_id=sample.get("user_id"),
            intercom_url=sample.get("intercom_url"),
            jarvis_org_url=sample.get("jarvis_org_url"),
            jarvis_user_url=sample.get("jarvis_user_url"),
        )
        description += f"### Sample {i}\n{formatted}\n\n"

    description += f"""---

## Review Checklist
- [ ] Classification accuracy looks correct
- [ ] Sample excerpts match the category
- [ ] No obvious misclassifications

---
*Generated by {pipeline_name}*
"""
    return description


def get_story_type(category: str) -> str:
    """
    Get Shortcut story type based on classification category.

    Args:
        category: Classification category name

    Returns:
        "bug", "feature", or "chore"
    """
    if category == "product_issue":
        return "bug"
    elif category == "feature_request":
        return "feature"
    else:
        return "chore"


def build_story_name(category: str, count: int, suffix: str = "Review") -> str:
    """
    Build consistent story name.

    Format: [count] Category Name - suffix

    Args:
        category: Classification category (snake_case)
        count: Number of conversations
        suffix: Story name suffix (default: "Review")

    Returns:
        Formatted story name
    """
    title = category.replace("_", " ").title()
    return f"[{count}] {title} - {suffix}"


def format_multi_source_evidence(
    intercom_samples: list[dict],
    coda_samples: list[dict],
    source_counts: dict,
) -> str:
    """
    Format evidence from multiple sources for story description.

    Creates a structured evidence section with quotes from both
    Intercom support conversations and Coda research.

    Args:
        intercom_samples: List of Intercom conversation samples
            - id: conversation ID
            - email: customer email
            - excerpt: conversation text
            - created_at: timestamp
        coda_samples: List of Coda research samples
            - page_name: source page name
            - participant: participant email
            - excerpt: research quote
            - theme_type: pain_point, feature_request, etc.
        source_counts: Dict of counts per source {"intercom": N, "coda": M}

    Returns:
        Formatted markdown evidence section
    """
    lines = ["## Evidence\n"]

    # Intercom section
    intercom_count = source_counts.get("intercom", 0)
    if intercom_count > 0 and intercom_samples:
        lines.append(f"### From Support (Intercom) - {intercom_count} conversations\n")
        for sample in intercom_samples[:5]:
            email = sample.get("email", "Customer")
            excerpt = sample.get("excerpt", "")[:200]
            conv_id = sample.get("id", "")
            intercom_url = f"https://app.intercom.com/a/apps/{INTERCOM_APP_ID}/inbox/inbox/conversation/{conv_id}"
            lines.append(f"- [{email}]({intercom_url}): \"{excerpt}...\"")
        lines.append("")

    # Coda section
    coda_count = source_counts.get("coda", 0)
    if coda_count > 0 and coda_samples:
        lines.append(f"### From Research (Coda) - {coda_count} interviews\n")
        for sample in coda_samples[:5]:
            participant = sample.get("participant", "Research participant")
            excerpt = sample.get("excerpt", "")[:200]
            theme_type = sample.get("theme_type", "insight")
            page_name = sample.get("page_name", "")

            # Format theme type as label
            type_label = theme_type.replace("_", " ").title()
            lines.append(f"- **{type_label}**: \"{excerpt}...\"")
            if participant:
                lines.append(f"  - From: {participant}")
        lines.append("")

    # Priority signal
    if intercom_count > 0 and coda_count > 0:
        lines.append("### Priority Signal\n")
        lines.append("âœ… **High Confidence** - Theme confirmed in both research interviews and support volume\n")
    elif coda_count > 0:
        lines.append("### Priority Signal\n")
        lines.append("ðŸ“Š **Strategic** - Theme from research interviews (proactive insight)\n")
    elif intercom_count > 0:
        lines.append("### Priority Signal\n")
        lines.append("ðŸŽ¯ **Tactical** - Theme from support volume (reactive signal)\n")

    return "\n".join(lines)


def build_multi_source_description(
    issue_signature: str,
    product_area: str,
    component: str,
    total_count: int,
    source_counts: dict,
    intercom_samples: list[dict] = None,
    coda_samples: list[dict] = None,
    root_cause_hypothesis: str = None,
    pipeline_name: str = "FeedForward Multi-Source Pipeline",
) -> str:
    """
    Build story description with multi-source evidence.

    Args:
        issue_signature: Theme signature
        product_area: Product area affected
        component: Component affected
        total_count: Total occurrences across all sources
        source_counts: Dict of counts per source
        intercom_samples: Intercom conversation samples
        coda_samples: Coda research samples
        root_cause_hypothesis: Analysis of root cause
        pipeline_name: Name of generating pipeline

    Returns:
        Formatted markdown description
    """
    intercom_count = source_counts.get("intercom", 0)
    coda_count = source_counts.get("coda", 0)

    # Determine confidence level
    if intercom_count > 0 and coda_count > 0:
        confidence = "âœ… High Confidence (Both Sources)"
    elif coda_count > 0:
        confidence = "ðŸ“Š Strategic (Research Only)"
    else:
        confidence = "ðŸŽ¯ Tactical (Support Only)"

    description = f"""## Theme Summary

**Issue**: {issue_signature.replace('_', ' ').title()}
**Product Area**: {product_area}
**Component**: {component}
**Total Reports**: {total_count}
**Confidence**: {confidence}

### Source Breakdown
- Intercom (Support): {intercom_count} conversations
- Coda (Research): {coda_count} interviews

---

"""

    # Add multi-source evidence
    evidence = format_multi_source_evidence(
        intercom_samples=intercom_samples or [],
        coda_samples=coda_samples or [],
        source_counts=source_counts,
    )
    description += evidence

    # Add root cause if available
    if root_cause_hypothesis:
        description += f"""
---

## Technical Context

**Root Cause Hypothesis**: {root_cause_hypothesis}
"""

    description += f"""
---

## Acceptance Criteria

- [ ] Root cause confirmed or updated
- [ ] Fix addresses both support and research feedback
- [ ] Regression testing on {product_area} functionality

---
*Generated by {pipeline_name}*
"""
    return description


def get_priority_label(source_counts: dict) -> str:
    """
    Get priority label based on source presence.

    Args:
        source_counts: Dict of counts per source

    Returns:
        Priority label string
    """
    has_coda = source_counts.get("coda", 0) > 0
    has_intercom = source_counts.get("intercom", 0) > 0

    if has_coda and has_intercom:
        return "high_confidence"
    elif has_coda:
        return "strategic"
    else:
        return "tactical"
