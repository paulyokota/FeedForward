"""
Shortcut story formatting - single source of truth.

All story creation should use these functions to ensure consistent formatting.

Format spec:
- Excerpts link to Intercom conversation, Jarvis org page, Jarvis user page
- Description includes category, count, percentage, samples, review checklist
- Footer identifies FeedForward as the generator
"""

import os
from typing import Optional, Dict, List

# Production Intercom app ID for URL generation
INTERCOM_APP_ID = os.getenv("INTERCOM_APP_ID", "2t3d8az2")
# Coda document ID for deep links to research data
CODA_DOC_ID = os.getenv("CODA_DOC_ID", "")
# Maximum characters for excerpt text in formatted output
EXCERPT_MAX_LENGTH = 300


def format_excerpt(
    conversation_id: str,
    email: Optional[str] = None,
    excerpt: str = "",
    org_id: Optional[str] = None,
    user_id: Optional[str] = None,
    intercom_url: Optional[str] = None,
    jarvis_org_url: Optional[str] = None,
    jarvis_user_url: Optional[str] = None,
) -> str:
    """
    Format a conversation excerpt with linked metadata.

    Format: [email](intercom_url) | [Org](jarvis_org_url) | [User](jarvis_user_url)
    > excerpt text...

    Args:
        conversation_id: Intercom conversation ID
        email: Customer email address
        excerpt: Conversation excerpt text
        org_id: Tailwind org ID (for Jarvis URL)
        user_id: Tailwind user ID (for Jarvis URL)
        intercom_url: Pre-built Intercom URL (optional, will build if not provided)
        jarvis_org_url: Pre-built Jarvis org URL (optional)
        jarvis_user_url: Pre-built Jarvis user URL (optional)

    Returns:
        Formatted markdown string
    """
    parts = []

    # Build URLs if not provided
    if not intercom_url:
        intercom_url = f"https://app.intercom.com/a/apps/{INTERCOM_APP_ID}/inbox/inbox/conversation/{conversation_id}"

    if not jarvis_org_url and org_id:
        jarvis_org_url = f"https://jarvis.tailwind.ai/organizations/{org_id}"

    if not jarvis_user_url and org_id and user_id:
        jarvis_user_url = f"https://jarvis.tailwind.ai/organizations/{org_id}/users/{user_id}"

    # Email linked to Intercom conversation
    display_email = email or f"Conversation {conversation_id}"
    parts.append(f"[{display_email}]({intercom_url})")

    # Org linked to Jarvis
    if jarvis_org_url:
        parts.append(f"[Org]({jarvis_org_url})")

    # User linked to Jarvis
    if jarvis_user_url:
        parts.append(f"[User]({jarvis_user_url})")

    user_info = " | ".join(parts)
    excerpt_text = excerpt[:EXCERPT_MAX_LENGTH] if excerpt else ""

    return f"{user_info}\n> {excerpt_text}"


def build_story_description(
    category: str,
    count: int,
    total: int,
    samples: list[dict],
    pipeline_name: str = "FeedForward Classification Pipeline",
    time_period: str = "Last 30 Days",
) -> str:
    """
    Build Shortcut story description with formatted excerpts.

    Args:
        category: Classification category name
        count: Number of conversations in this category
        total: Total conversations analyzed
        samples: List of sample conversation dicts with keys:
            - id: conversation ID
            - email: customer email (optional)
            - excerpt: conversation text
            - org_id: Tailwind org ID (optional)
            - user_id: Tailwind user ID (optional)
            - intercom_url: pre-built URL (optional)
            - jarvis_org_url: pre-built URL (optional)
            - jarvis_user_url: pre-built URL (optional)
        pipeline_name: Name of the generating pipeline
        time_period: Description of time period analyzed

    Returns:
        Formatted markdown description
    """
    pct = count / total * 100 if total > 0 else 0

    description = f"""## Classification Results ({time_period})

**Category**: {category}
**Count**: {count} ({pct:.1f}% of total)
**Total Conversations Analyzed**: {total}

---

## Sample Conversations

"""
    for i, sample in enumerate(samples[:5], 1):
        formatted = format_excerpt(
            conversation_id=sample.get("id", "unknown"),
            email=sample.get("email"),
            excerpt=sample.get("excerpt", ""),
            org_id=sample.get("org_id"),
            user_id=sample.get("user_id"),
            intercom_url=sample.get("intercom_url"),
            jarvis_org_url=sample.get("jarvis_org_url"),
            jarvis_user_url=sample.get("jarvis_user_url"),
        )
        description += f"### Sample {i}\n{formatted}\n\n"

    description += f"""---

## Review Checklist
- [ ] Classification accuracy looks correct
- [ ] Sample excerpts match the category
- [ ] No obvious misclassifications

---
*Generated by {pipeline_name}*
"""
    return description


def get_story_type(category: str) -> str:
    """
    Get Shortcut story type based on classification category.

    Args:
        category: Classification category name

    Returns:
        "bug", "feature", or "chore"
    """
    if category == "product_issue":
        return "bug"
    elif category == "feature_request":
        return "feature"
    else:
        return "chore"


def build_story_name(category: str, count: int, suffix: str = "Review") -> str:
    """
    Build consistent story name.

    Format: [count] Category Name - suffix

    Args:
        category: Classification category (snake_case)
        count: Number of conversations
        suffix: Story name suffix (default: "Review")

    Returns:
        Formatted story name
    """
    title = category.replace("_", " ").title()
    return f"[{count}] {title} - {suffix}"


def format_multi_source_evidence(
    intercom_samples: list[dict],
    coda_samples: list[dict],
    source_counts: dict,
) -> str:
    """
    Format evidence from multiple sources for story description.

    Creates a structured evidence section with quotes from both
    Intercom support conversations and Coda research.

    Args:
        intercom_samples: List of Intercom conversation samples
            - id: conversation ID
            - email: customer email
            - excerpt: conversation text
            - created_at: timestamp
        coda_samples: List of Coda research samples
            - page_name: source page name
            - participant: participant email
            - excerpt: research quote
            - theme_type: pain_point, feature_request, etc.
        source_counts: Dict of counts per source {"intercom": N, "coda": M}

    Returns:
        Formatted markdown evidence section
    """
    lines = ["## Evidence\n"]

    # Intercom section
    intercom_count = source_counts.get("intercom", 0)
    if intercom_count > 0 and intercom_samples:
        lines.append(f"### From Support (Intercom) - {intercom_count} conversations\n")
        for sample in intercom_samples[:5]:
            email = sample.get("email", "Customer")
            excerpt = sample.get("excerpt", "")[:200]
            conv_id = sample.get("id", "")
            intercom_url = f"https://app.intercom.com/a/apps/{INTERCOM_APP_ID}/inbox/inbox/conversation/{conv_id}"
            lines.append(f"- [{email}]({intercom_url}): \"{excerpt}...\"")
        lines.append("")

    # Coda section
    coda_count = source_counts.get("coda", 0)
    if coda_count > 0 and coda_samples:
        lines.append(f"### From Research (Coda) - {coda_count} interviews\n")
        for sample in coda_samples[:5]:
            participant = sample.get("participant", "Research participant")
            excerpt = sample.get("excerpt", "")[:200]
            theme_type = sample.get("theme_type", "insight")
            page_name = sample.get("page_name", "")

            # Format theme type as label
            type_label = theme_type.replace("_", " ").title()
            lines.append(f"- **{type_label}**: \"{excerpt}...\"")
            if participant:
                lines.append(f"  - From: {participant}")
        lines.append("")

    # Priority signal
    if intercom_count > 0 and coda_count > 0:
        lines.append("### Priority Signal\n")
        lines.append("âœ… **High Confidence** - Theme confirmed in both research interviews and support volume\n")
    elif coda_count > 0:
        lines.append("### Priority Signal\n")
        lines.append("ðŸ“Š **Strategic** - Theme from research interviews (proactive insight)\n")
    elif intercom_count > 0:
        lines.append("### Priority Signal\n")
        lines.append("ðŸŽ¯ **Tactical** - Theme from support volume (reactive signal)\n")

    return "\n".join(lines)


def build_multi_source_description(
    issue_signature: str,
    product_area: str,
    component: str,
    total_count: int,
    source_counts: dict,
    intercom_samples: list[dict] = None,
    coda_samples: list[dict] = None,
    root_cause_hypothesis: str = None,
    pipeline_name: str = "FeedForward Multi-Source Pipeline",
) -> str:
    """
    Build story description with multi-source evidence.

    Args:
        issue_signature: Theme signature
        product_area: Product area affected
        component: Component affected
        total_count: Total occurrences across all sources
        source_counts: Dict of counts per source
        intercom_samples: Intercom conversation samples
        coda_samples: Coda research samples
        root_cause_hypothesis: Analysis of root cause
        pipeline_name: Name of generating pipeline

    Returns:
        Formatted markdown description
    """
    intercom_count = source_counts.get("intercom", 0)
    coda_count = source_counts.get("coda", 0)

    # Determine confidence level
    if intercom_count > 0 and coda_count > 0:
        confidence = "âœ… High Confidence (Both Sources)"
    elif coda_count > 0:
        confidence = "ðŸ“Š Strategic (Research Only)"
    else:
        confidence = "ðŸŽ¯ Tactical (Support Only)"

    description = f"""## Theme Summary

**Issue**: {issue_signature.replace('_', ' ').title()}
**Product Area**: {product_area}
**Component**: {component}
**Total Reports**: {total_count}
**Confidence**: {confidence}

### Source Breakdown
- Intercom (Support): {intercom_count} conversations
- Coda (Research): {coda_count} interviews

---

"""

    # Add multi-source evidence
    evidence = format_multi_source_evidence(
        intercom_samples=intercom_samples or [],
        coda_samples=coda_samples or [],
        source_counts=source_counts,
    )
    description += evidence

    # Add root cause if available
    if root_cause_hypothesis:
        description += f"""
---

## Technical Context

**Root Cause Hypothesis**: {root_cause_hypothesis}
"""

    description += f"""
---

## Acceptance Criteria

- [ ] Root cause confirmed or updated
- [ ] Fix addresses both support and research feedback
- [ ] Regression testing on {product_area} functionality

---
*Generated by {pipeline_name}*
"""
    return description


def get_priority_label(source_counts: dict) -> str:
    """
    Get priority label based on source presence.

    Args:
        source_counts: Dict of counts per source

    Returns:
        Priority label string
    """
    has_coda = source_counts.get("coda", 0) > 0
    has_intercom = source_counts.get("intercom", 0) > 0

    if has_coda and has_intercom:
        return "high_confidence"
    elif has_coda:
        return "strategic"
    else:
        return "tactical"


def format_coda_excerpt(
    text: str,
    table_name: Optional[str] = None,
    participant: Optional[str] = None,
    page_id: Optional[str] = None,
    row_id: Optional[str] = None,
    coda_doc_id: Optional[str] = None,
) -> str:
    """
    Format Coda research excerpt with links.

    Format: [Participant or Table](Coda URL)
    > "Quote from research..."

    Link generation strategy:
    - For table rows: https://coda.io/d/{doc_id}#row-{row_id}
    - For pages: https://coda.io/d/{doc_id}/_/{page_id}
    - Fallback: https://coda.io/d/{doc_id} (doc root)

    Args:
        text: Excerpt text
        table_name: Table name (for display)
        participant: Participant identifier (for display)
        page_id: Coda page ID
        row_id: Coda row ID
        coda_doc_id: Coda doc ID (optional, defaults to env)

    Returns:
        Formatted markdown string
    """
    doc_id = coda_doc_id or CODA_DOC_ID

    # Build URL based on available identifiers
    if row_id and doc_id:
        url = f"https://coda.io/d/{doc_id}#row-{row_id}"
    elif page_id and doc_id:
        url = f"https://coda.io/d/{doc_id}/_/{page_id}"
    elif doc_id:
        url = f"https://coda.io/d/{doc_id}"
    else:
        url = "https://coda.io"

    # Display label priority: participant > table_name > "Research"
    if participant:
        display = participant
    elif table_name:
        display = table_name
    else:
        display = "Research"

    excerpt_text = text[:300] if text else ""
    return f"[{display}]({url})\n> {excerpt_text}"


def format_excerpt_multi_source(
    source: str,
    text: str,
    conversation_id: Optional[str] = None,
    source_metadata: Optional[Dict] = None,
) -> str:
    """
    Route to source-specific formatting.

    For Intercom: Uses existing format_excerpt() with Jarvis links
    For Coda: Uses format_coda_excerpt() with Coda doc links

    Args:
        source: "intercom" or "coda"
        text: Excerpt text
        conversation_id: Intercom conversation ID (for intercom source)
        source_metadata: Dict with source-specific fields:
            For Intercom: email, org_id, user_id, urls
            For Coda: table_name, participant, page_id, row_id

    Returns:
        Formatted markdown string
    """
    metadata = source_metadata or {}

    if source == "intercom":
        return format_excerpt(
            conversation_id=conversation_id or "unknown",
            email=metadata.get("email"),
            excerpt=text,
            org_id=metadata.get("org_id"),
            user_id=metadata.get("user_id"),
            intercom_url=metadata.get("intercom_url"),
            jarvis_org_url=metadata.get("jarvis_org_url"),
            jarvis_user_url=metadata.get("jarvis_user_url"),
        )
    elif source == "coda":
        return format_coda_excerpt(
            text=text,
            table_name=metadata.get("table_name"),
            participant=metadata.get("participant"),
            page_id=metadata.get("page_id"),
            row_id=metadata.get("row_id"),
            coda_doc_id=metadata.get("coda_doc_id"),
        )
    else:
        # Unknown source: return plain text
        return f"> {text[:300]}"


def build_research_story_description(
    theme_name: str,
    excerpts: List[Dict],
    participant_count: int,
    theme_type: str,
    source_breakdown: Dict[str, int],
) -> str:
    """
    Build description optimized for research-sourced stories.

    Structure (different from bug reports):
    1. Theme Summary (what users are saying)
    2. Research Context (participant count, sources)
    3. Representative Quotes (with links)
    4. Suggested Investigation (product questions)
    5. Acceptance Criteria (validation approach)

    Args:
        theme_name: Theme name
        excerpts: List of excerpt dicts with keys:
            - source: "intercom" or "coda"
            - text: excerpt text
            - source_metadata: source-specific metadata
        participant_count: Number of research participants
        theme_type: pain_point, feature_request, or insight
        source_breakdown: Dict of counts per source

    Returns:
        Formatted markdown description
    """
    # Theme type label
    type_label = theme_type.replace("_", " ").title()

    # Build description header
    description = f"""## Theme Summary

**Theme**: {theme_name.replace('_', ' ').title()}
**Type**: {type_label}
**Participants**: {participant_count}

### Source Breakdown
"""

    # Add source breakdown
    for source, count in source_breakdown.items():
        source_label = source.title()
        description += f"- {source_label}: {count}\n"

    description += "\n---\n\n## Representative Quotes\n\n"

    # Add formatted excerpts
    for i, excerpt in enumerate(excerpts[:5], 1):
        source = excerpt.get("source", "unknown")
        text = excerpt.get("text", "")
        metadata = excerpt.get("source_metadata", {})
        conversation_id = excerpt.get("conversation_id")

        formatted = format_excerpt_multi_source(
            source=source,
            text=text,
            conversation_id=conversation_id,
            source_metadata=metadata,
        )
        description += f"### Quote {i}\n{formatted}\n\n"

    # Add investigation section
    description += """---

## Suggested Investigation

- What user needs does this theme reveal?
- How does this align with product strategy?
- What additional validation is needed?
- What are the potential solutions?

---

## Acceptance Criteria

- [ ] Theme validated with additional user research
- [ ] Product opportunity sized and prioritized
- [ ] Solution approach defined
- [ ] Next steps identified

---
*Generated by FeedForward Research Pipeline*
"""
    return description
